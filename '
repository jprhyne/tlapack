/// @file test_eispack_hqr.cpp
/// @brief Test HQR. 
//
// Copyright (c) 2022, University of Colorado Denver. All rights reserved.
//
// This file is part of <T>LAPACK.
// <T>LAPACK is free software: you can redistribute it and/or modify it under
// the terms of the BSD 3-Clause license. See the accompanying LICENSE file.

#include <catch2/catch_template_test_macros.hpp>
#include <catch2/generators/catch_generators.hpp>

#include "testutils.hpp"

#include <tlapack/lapack/eispack_hqr.hpp>

#include <tlapack/lapack/lacpy.hpp>
#include <tlapack/lapack/lange.hpp>
#include <tlapack/lapack/gehrd.hpp>
#include <tlapack/lapack/unghr.hpp>

// Auxiliary routines

using namespace tlapack;
// Rework to be near identical to test_blocked_francis.cpp FORM
TEMPLATE_TEST_CASE("schur form is backwards stable", "[hqr][schur]", TLAPACK_REAL_TYPES_TO_TEST)
{
    //srand(1);

    rand_generator gen;
    

    using matrix_t = TestType;
    using T = type_t<matrix_t>;
    using idx_t = size_type<matrix_t>;
    using range = std::pair<idx_t, idx_t>;
    typedef real_type<T> real_t;

    idx_t n;
    auto matrix_type = GENERATE(as<std::string>{}, "Full Matrix", "Inner Window");
    idx_t seed = GENERATE(123,623,134,5); // Numbers generated by my shell's random
    gen.seed(seed);
    //n = GENERATE(5, 10, 30, 50, 100, 125, 150, 250,  300, 400, 500);
    n = GENERATE(1, 2, 3, 4, 5, 10, 30, 32, 33, 41);

    INFO("n=" << n);
    const real_t eps = uroundoff<real_t>(); 
    const T tol = T( 10 * n *  eps);

    T zero = T(0);
    T one = T(1);

    // Function
    Create<matrix_t> new_matrix;


    // Create matrices
    std::vector<T> A_; auto A = new_matrix( A_, n, n);
    std::vector<T> U_; auto U = new_matrix( U_, n, n);
    std::vector<T> H_; auto H = new_matrix( H_, n, n);
    std::vector<T> Q_; auto Q = new_matrix( Q_, n, n);
    std::vector<T> eye_; auto eye = new_matrix( eye_, n, n);
    std::vector<T> wr(n);
    std::vector<T> wi(n);
    //Populate A and U with random numbers
    for(idx_t i = 0; i < n; i++) {
        for(idx_t j = 0; j < n; j++) {
            T val = rand_helper<T>(gen);
            A(i,j) = val; 
            H(i,j) = val; 
        }
    }
    std::vector<T> tau(n);
    gehrd(0, n, H, tau);
    lacpy(Uplo::General, H, Q);
    unghr(0, n, Q, tau);
    idx_t ilo = 0;
    idx_t igh = n - 1;
    for (idx_t i = 1; i < n; i++) 
        for (idx_t j = 0; j < i - 1; j++) 
            H(i,j) = zero;
    //copy H into U to ensure our
    //hessenberg reduction works as expected
    //lacpy(Uplo::General, H, U);
    // Construct the identity matrix
    for (idx_t i = 0; i < n; i++) 
        for (idx_t j = 0; j < n; j++) 
            eye(i,j) = (i == j) ? (one) : (zero);
    /*
    if (matrix_type == "Inner Window") {
        // leave above diagonal alone
        ilo = n/4;
        igh = 3 * n / 4;
        for (idx_t j = 0; j < ilo; ++j) {
            for (idx_t i = j + 1; i < n; ++i) {
                A(i,j) = zero;
                U(i,j) = zero;
            }
        }
        for (idx_t i = igh; i < n; ++i) {
            for (idx_t j = 0; j < i; ++j) {
                A(i,j) = zero;
                U(i,j) = zero;
            }
        }
    }
    */

    //Call hqr
    real_t norm = real_t(zero);
    // REname to EISPACK_HQR
    int retCode = tlapack::eispack_hqr(H, ilo, igh, wr, wi, true, Q, norm);
    CHECK(retCode == 0);

    // Getting here means that we have successfully ran all of 
    // hqr and got an answer, so now we check if our Schur vectors are correct
    //  check || Q' * Q - I ||_F
    std::vector<T> res_; auto res = new_matrix( res_, n, n );
    auto orthZ = check_orthogonality(Q,res);
    
    CHECK(orthZ <= tol);
    // Zero out below quasi diagonal elements of T
    // First, zero out everything below the 1st subdiagonal
    for (idx_t i = 1; i < n; i++) 
        for (idx_t j = 0; j < i - 1; j++) 
            H(i,j) = 0;
    // if eigValsImag[k]  = 0 then the sub diagonal elements need to be 0
    // If eigValsImag[k] != 0 then we have a schur block  
    idx_t k;
    for (k = 0; k < n-1; k++) {
        if (wi[k] == zero) {
            H(k+1,k) = zero;
        } else if (k < n-2){
            // This means we are in a schur block, so the next sub diagonal
            // element must be 0
            H(k+2,k+1) = zero;
            k++;
        }
    }
    //  check || U - Q * H * Q^T ||_F / || A ||_F
    auto normA = lange(tlapack::frob_norm, A);
    auto sim_res_norm = check_similarity_transform(A,Q,H);
    CHECK(sim_res_norm <= tol * normA);
    /*
    std::cout << "Schur Vectors of the Hessenberg matrix\n";
    for (idx_t i = 0; i < n; i++) {
        for (idx_t j = 0; j < n; j++) {
            std::cout << eye(i,j) << " ";
        }
        std::cout << "\n";
    }
    std::cout << "\n";
    std::cout << "Q gotten from the Hessenberg reduction\n";
    for (idx_t i = 0; i < n; i++) {
        for (idx_t j = 0; j < n; j++) {
            std::cout << Q(i,j) << " ";
        }
        std::cout << "\n";
    }
    std::cout << "\n";
    std::cout << "Product of Q and the Schur Vectors\n";
    for (idx_t i = 0; i < n; i++) {
        for (idx_t j = 0; j < n; j++) {
            std::cout << tmp(i,j) << " ";
        }
        std::cout << "\n";
    }
    std::cout << "\n";
    std::cout << "Result of A - Qschur H schur^T Q^T\n";
    for (idx_t i = 0; i < n; i++) {
        for (idx_t j = 0; j < n; j++) {
            std::cout << temp(i,j) << " ";
        }
        std::cout << "\n";
    }
    std::cout << "\n";
    sim_res_norm = check_similarity_transform(A,tmp,H);
    CHECK(sim_res_norm <= tol * normA);
    */
}
