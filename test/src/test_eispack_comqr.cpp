/// @file test_eispack_comqr.cpp
/// @brief Test HQR. 
//
// Copyright (c) 2022, University of Colorado Denver. All rights reserved.
//
// This file is part of <T>LAPACK.
// <T>LAPACK is free software: you can redistribute it and/or modify it under
// the terms of the BSD 3-Clause license. See the accompanying LICENSE file.

#include <catch2/catch_template_test_macros.hpp>
#include <catch2/generators/catch_generators.hpp>

#include "testutils.hpp"
#include <tlapack/lapack/lacpy.hpp>
#include <tlapack/lapack/lange.hpp>
#include <tlapack/lapack/gehrd.hpp>
#include <tlapack/lapack/unghr.hpp>
#include <tlapack/lapack/getri.hpp>
#include <tlapack/lapack/getrf.hpp>
#include <tlapack/blas/gemm.hpp>

#include <tlapack/lapack/eispack_hqr.hpp>
#include <tlapack/lapack/eispack_schurToEigen.hpp>
#include <tlapack/lapack/multishift_qr.hpp>

// Auxiliary routines

using namespace tlapack;
// Rework to be near identical to test_blocked_francis.cpp FORM
TEMPLATE_TEST_CASE("schur form is backwards stable", "[hqr][schur]", TLAPACK_COMPLEX_TYPES_TO_TEST)
{
    //srand(1);

    rand_generator gen;
    

    using matrix_t = TestType;
    using T = type_t<matrix_t>;
    using idx_t = size_type<matrix_t>;
    using real_t = real_type<T>;
    using complex_t = complex_type<T>;

    idx_t n;
    auto matrix_type = GENERATE(as<std::string>{}, "Full Matrix");
    auto schur_type = GENERATE(as<std::string>{}, "Eispack", "Thijs");
    auto testing_scheme = GENERATE(as<std::string>{}, "Eigenvalues", "Schur Form", "Eigenvectors");
    idx_t seed = GENERATE(123,623,134,5); // Numbers generated by my shell's random
    gen.seed(seed);
    n = GENERATE(1, 2, 3, 4, 5, 10, 30, 32, 33, 41);

    INFO("n=" << n);
    INFO("schur_type: " << schur_type);
    INFO("testing_scheme: " << testing_scheme);
    const real_t eps = uroundoff<real_t>(); 
    const real_t tol = real_t( 10 * n *  eps);

    T zero = T(0);

    // Function
    Create<matrix_t> new_matrix;


    // Create matrices
    std::vector<T> A_; auto A = new_matrix( A_, n, n);
    std::vector<T> H_; auto H = new_matrix( H_, n, n);
    std::vector<T> Q_; auto Q = new_matrix( Q_, n, n);
    std::vector<T> Z_; auto Z = new_matrix( Z_, n, n);
    std::vector<complex_t> s(n);
    //Populate A and U with random numbers
    for(idx_t i = 0; i < n; i++) {
        for(idx_t j = 0; j < n; j++) {
            T val = rand_helper<T>(gen);
            A(i,j) = val; 
            H(i,j) = val; 
        }
    }
    std::vector<T> tau(n);
    gehrd(0, n, H, tau);
    lacpy(Uplo::General, H, Q);
    unghr(0, n, Q, tau);
    idx_t ilo = 0;
    idx_t igh = n;
    for (idx_t i = 1; i < n; i++) 
        for (idx_t j = 0; j < i - 1; j++) 
            H(i,j) = zero;
    //copy H into U to ensure our
    //hessenberg reduction works as expected
    real_t sim_res_norm = check_similarity_transform(A,Q,H);
    real_t normA = lange(tlapack::frob_norm, A);
    CHECK(sim_res_norm < tol * normA);
    lacpy(Uplo::General, Q,Z);
    if (testing_scheme == "Eigenvalues") {
    } else if (testing_scheme == "Schur Form") {
        int retCode;
        //Call hqr
        real_t norm = real_t(0);
      retCode = tlapack::eispack_comqr(true, true, ilo, igh, H, s, Q, norm);
        CHECK(retCode == 0);
        // Getting here means that we have successfully ran all of 
        // hqr and got an answer, so now we check if our Schur vectors are correct
        //  check || Q' * Q - I ||_F
        std::vector<T> res_; auto res = new_matrix( res_, n, n );
        real_t orthZ = check_orthogonality(Q,res);
        
    
        CHECK(orthZ <= tol);
        // Zero out below diagonal elements of T
        for (idx_t i = 1; i < n; i++) 
            for (idx_t j = 0; j <= i - 1; j++) 
                H(i,j) = zero;
        //  check || A - Q * H * Q^T ||_F / || A ||_F
        sim_res_norm = check_similarity_transform(A,Q,H);
        CHECK(sim_res_norm <= tol * normA);
    } else {
       real_t norm = 0;
        idx_t retCode;
        if (schur_type == "Thijs") {
            //Call Thijs' function to ensure we
            //work for other schur form computations
            idx_t ns = 4;
            idx_t nw = 4;
            francis_opts_t<idx_t> opts;
            opts.nshift_recommender = [ns](idx_t n, idx_t nh) -> idx_t 
            {
                return ns;
            };
            opts.deflation_window_recommender = [nw](idx_t n, idx_t nh) -> idx_t
            {
                return nw;
            };
            opts.nmin = 15;
    
            // Compute the norm of H as this is needed for schurToEigen
            for (idx_t i = 0; i < n; i++) 
                for (idx_t j = 0; j < n; j++) 
                    norm += tlapack::abs(H(i,j));
            retCode = multishift_qr(true, true, 0, n, H, s, Z, opts);
            // Ensure we actually finished hqr.
            CHECK(retCode == 0);
        } else {
            //Call hqr
            retCode = eispack_comqr(true, true, 0, n, H, s, Z, norm);
            CHECK(retCode == 0);
        }
        // call hqr and comqr respectively
        // Getting here means that we have successfully ran all of hqr
        retCode = eispack_comqr_schurToEigen(H, 0, n, s, Z, norm);
        CHECK(retCode == 0);
        // We will test representativity by constructing a matrix Zc such that Zc contains 
        // the eigenvectors stored in Z but as complex numbers
        // Similarly, do so for Dc containing the eigenvalues stored as complex numbers
        std::vector<std::complex<real_t>> Zc_; auto Zc = new_matrix( Zc_, n, n);
    	lacpy(Uplo::General,Z,Zc);
        std::vector<std::complex<real_t>> Zi_; auto Zi = new_matrix( Zi_, n, n);
        lacpy(Uplo::General, Zc, Zi);
        std::vector<idx_t> Piv(n);
        // Perform LU Decomp of Zi
        retCode = getrf(Zi,Piv);
        CHECK(retCode == 0); // Ensure we properly computed the LU
        // Now compute the inverse of Zi
        // Note: This function is somehow treating Piv as a vector of complex numbers
        retCode = getri(Zi,Piv);
        CHECK(retCode == 0); // Ensure we properly computed the Inverse
        // Now test VDV^{-1} - A
        std::vector<std::complex<real_t>> lhs_; auto lhs = new_matrix( lhs_, n, n);
        std::vector<std::complex<real_t>> Dc_; auto Dc = new_matrix( Dc_, n, n);
        for (idx_t i = 0; i < n; i++)
            Dc(i,i) = s[i];
        // We need to also construct Ac which is just a complex equivalent of A
        // with 0 for all imaginary parts
        std::vector<std::complex<real_t>> Ac_; auto Ac = new_matrix( Ac_, n, n);
        lacpy(Uplo::General, A, Ac);
    
        gemm(Op::NoTrans, Op::NoTrans, real_t(1), Zc, Dc, lhs);
        // Note: This overwrites A, but we already have the norm of A saved from hqr
        gemm(Op::NoTrans, Op::NoTrans, real_t(1), lhs, Zi, real_t(-1), Ac);
        // Compute the frobenius norm of the residual
        real_t normR = lange(tlapack::frob_norm, Ac);
        real_t normZ = lange(tlapack::frob_norm, Zc);
        real_t normZi = lange(tlapack::frob_norm, Zi);
        real_t normD = lange(tlapack::frob_norm, Dc);
        CHECK(normR <= tol * normZ * normZi * normD);
    }
}
